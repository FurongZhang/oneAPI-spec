<!--
SPDX-FileCopyrightText: 2019-2020 Intel Corporation

SPDX-License-Identifier: MIT
-->



<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Specific API of oneDPL &mdash; oneAPI Specification 1.0-rev-2 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicons.png"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/custom.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="oneDNN" href="../../oneDNN/source/index.html" />
    <link rel="prev" title="Extensions to Parallel STL" href="pstl.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="https://oneapi.com" class="icon icon-home"> oneAPI Specification
          

          
            
            <img src="../../../_static/oneAPI-rgb-rev-100.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0-rev-2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture.html">Software Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dpcpp/source/index.html">DPC++</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">oneDPL</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="common.html">Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="stdlib.html">Supported C++ Standard Library APIs and Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="pstl.html">Extensions to Parallel STL</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Specific API of oneDPL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-objects">Function Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterators">Iterators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallel-algorithms">Parallel Algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../oneDNN/source/index.html">oneDNN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oneCCL/source/index.html">oneCCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../l0/source/index.html">Level Zero</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oneDAL/source/index.html">oneDAL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oneTBB/source/nested-index.html">oneTBB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oneVPL/source/index.html">oneVPL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oneMKL/source/index.html">oneMKL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../versions.html">HTML and PDF Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notices.html">Legal Notices and Disclaimers</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">oneAPI Specification</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <!--
SPDX-FileCopyrightText: 2019-2020 Intel Corporation

SPDX-License-Identifier: MIT
-->

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">oneAPI Specification</a> &raquo;</li>
        
          
          <li><a href="index.html">oneDPL</a> </li>
          
        
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/oneapi-src/oneapi-spec/blob/master/source/elements/oneDPL/source/extensions.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="specific-api-of-onedpl">
<h1>Specific API of oneDPL<a class="headerlink" href="#specific-api-of-onedpl" title="Permalink to this headline">¶</a></h1>
<p>The oneDPL extensions include iterators, function objects, and parallel algorithms.</p>
<div class="section" id="function-objects">
<h2>Function Objects<a class="headerlink" href="#function-objects" title="Permalink to this headline">¶</a></h2>
<p>The oneDPL function objects are defined in the <code class="code docutils literal notranslate"><span class="pre">&lt;oneapi/dpl/functional&gt;</span></code> header,
in <code class="code docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">oneapi::dpl</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">oneapi</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">dpl</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">identity</span>
    <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">constexpr</span> <span class="n">T</span><span class="o">&amp;&amp;</span>
        <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::identity</span></code> class implements an identity operation. Its function operator
receives an instance of a type and returns the argument unchanged.</p>
</div>
<div class="section" id="iterators">
<h2>Iterators<a class="headerlink" href="#iterators" title="Permalink to this headline">¶</a></h2>
<p>The oneDPL iterators are defined in the <code class="code docutils literal notranslate"><span class="pre">&lt;oneapi/dpl/iterator&gt;</span></code> header,
in <code class="code docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">oneapi::dpl</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Integral</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">counting_iterator</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="cm">/* a signed integer type of the same size as Integral */</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">;</span>

    <span class="n">counting_iterator</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="nf">counting_iterator</span><span class="p">(</span><span class="n">Integral</span> <span class="n">init</span><span class="p">);</span>

    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">difference_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">difference_type</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">counting_iterator</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">counting_iterator</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">);</span>
    <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">);</span>

    <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">counting_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">counting_iterator</span></code> is a random access iterator-like type that represents an integer counter.
When dereferenced, <code class="code docutils literal notranslate"><span class="pre">counting_iterator</span></code> provides an Integral rvalue equal to the value of the
counter; dereference operations cannot be used to modify the counter. The arithmetic and comparison
operators of <code class="code docutils literal notranslate"><span class="pre">counting_iterator</span></code> behave as if applied to the values of Integral type
representing the counters of the iterator instances passed to the operators.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">discard_iterator</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="cm">/* unspecified */</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="cm">/* unspecified */</span><span class="p">;</span>

    <span class="n">discard_iterator</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="nf">discard_iterator</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">init</span><span class="p">);</span>

    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">difference_type</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">difference_type</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">discard_iterator</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">discard_iterator</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">);</span>
    <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">);</span>

    <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">discard_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">discard_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">discard_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">discard_iterator</span></code> is a random access iterator-like type that, when dereferenced, provides an
lvalue that may be assigned an arbitrary value. The assignment has no effect on the
<code class="code docutils literal notranslate"><span class="pre">discard_iterator</span></code> instance; the write is discarded. The arithmetic and comparison operators
of <code class="code docutils literal notranslate"><span class="pre">discard_iterator</span></code> behave as if applied to integer counter values maintained by the
iterator instances to determine their position relative to each other.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">SourceIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">IndexMap</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">permutation_iterator</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span>
        <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">SourceIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">SourceIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">SourceIterator</span><span class="o">&gt;::</span><span class="n">pointer</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">SourceIterator</span><span class="o">&gt;::</span><span class="n">reference</span><span class="p">;</span>

    <span class="n">permutation_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">SourceIterator</span><span class="o">&amp;</span> <span class="n">input1</span><span class="p">,</span> <span class="k">const</span> <span class="n">IndexMap</span><span class="o">&amp;</span> <span class="n">input2</span><span class="p">,</span>
                         <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">difference_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">difference_type</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">permutation_iterator</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">permutation_iterator</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">);</span>
    <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">);</span>

    <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">permutation_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">permutation_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">permutation_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">permutation_iterator</span></code> is a random access iterator-like type whose dereferenced value set is
defined by the source iterator provided, and whose iteration order over the dereferenced value set
is defined by either another iterator or a functor that maps the <code class="code docutils literal notranslate"><span class="pre">permutation_iterator</span></code> index
to the index of the source iterator. The arithmetic and comparison operators of
<code class="code docutils literal notranslate"><span class="pre">permutation_iterator</span></code> behave as if applied to integer counter values maintained by the
iterator instances to determine their position in the index map.</p>
<p><code class="code docutils literal notranslate"><span class="pre">permutation_iterator::operator*</span></code> uses the counter value of the instance on which
it is invoked to index into the index map. The corresponding value in the map is then used
to index into the value set defined by the source iterator. The resulting lvalue is returned
as the result of the operator.</p>
<p><code class="code docutils literal notranslate"><span class="pre">permutation_iterator::operator[]</span></code> uses the parameter <code class="code docutils literal notranslate"><span class="pre">i</span></code>
to index into the index map. The corresponding value in the map is then used
to index into the value set defined by the source iterator. The resulting lvalue is returned
as the result of the operator.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">SourceIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">IndexMap</span><span class="o">&gt;</span>
<span class="n">permutation_iterator</span><span class="o">&lt;</span><span class="n">SourceIterator</span><span class="p">,</span> <span class="n">IndexMap</span><span class="o">&gt;</span>
<span class="n">make_permutation_iterator</span><span class="p">(</span><span class="n">SourceIterator</span> <span class="n">source</span><span class="p">,</span> <span class="n">IndexMap</span> <span class="n">map</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">make_permutation_iterator</span></code> constructs and returns an instance of <code class="code docutils literal notranslate"><span class="pre">permutation_iterator</span></code>
using the source iterator and index map provided.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">UnaryFunc</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">transform_iterator</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;::</span><span class="n">difference_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="n">UnaryFunc</span><span class="p">,</span>
                          <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;::</span><span class="n">reference</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">reference</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;::</span><span class="n">pointer</span><span class="p">;</span>

    <span class="n">transform_iterator</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">it</span><span class="p">,</span> <span class="n">UnaryFunc</span> <span class="n">unary_func</span><span class="p">);</span>
    <span class="n">transform_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
    <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>

    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">difference_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">difference_type</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span>

    <span class="n">transform_iterator</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">transform_iterator</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">);</span>
    <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">);</span>

    <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">transform_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">transform_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">transform_iterator</span></code> is a random access iterator-like type whose dereferenced value set is
defined by the unary function and source iterator provided. When dereferenced,
<code class="code docutils literal notranslate"><span class="pre">transform_iterator</span></code> provides the result of the unary function applied to the corresponding
element of the source iterator; dereference operations cannot be used to modify the elements of
the source iterator unless the unary function result includes a reference to the element. The
arithmetic and comparison operators of <code class="code docutils literal notranslate"><span class="pre">transform_iterator</span></code> behave as if applied to the
source iterator itself.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">UnaryFunc</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
<span class="n">transform_iterator</span><span class="o">&lt;</span><span class="n">UnaryFunc</span><span class="p">,</span> <span class="n">Iterator</span><span class="o">&gt;</span>
<span class="n">make_transform_iterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">UnaryFunc</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">make_transform_iterator</span></code> constructs and returns an instance of <code class="code docutils literal notranslate"><span class="pre">transform_iterator</span></code>
using the source iterator and unary function object provided.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Iterators</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">zip_iterator</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">make_signed</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">Iterators</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="cm">/* unspecified tuple of reference types */</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">Iterators</span><span class="o">&gt;::</span><span class="n">pointer</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">zip_iterator</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="nf">zip_iterator</span><span class="p">(</span><span class="n">Iterators</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">zip_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
    <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>

    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span><span class="n">difference_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">difference_type</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">zip_iterator</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">zip_iterator</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">forward</span><span class="p">);</span>
    <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">difference_type</span> <span class="n">backward</span><span class="p">);</span>

    <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
    <span class="n">zip_iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">zip_iterator</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">zip_iterator</span></code> is an iterator-like type defined over one or more iterators. When dereferenced,
the value returned from <code class="code docutils literal notranslate"><span class="pre">zip_iterator</span></code> is a tuple of the values returned by dereferencing the
source iterators over which the <code class="code docutils literal notranslate"><span class="pre">zip_iterator</span></code> is defined.  The arithmetic operators of
<code class="code docutils literal notranslate"><span class="pre">zip_iterator</span></code> update the source iterators of a <code class="code docutils literal notranslate"><span class="pre">zip_iterator</span></code> instance as though the
operation were applied to each of these iterators.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Iterators</span><span class="o">&gt;</span>
<span class="n">zip_iterator</span><span class="o">&lt;</span><span class="n">Iterators</span><span class="p">...</span><span class="o">&gt;</span>
<span class="n">make_zip_iterator</span><span class="p">(</span><span class="n">Iterators</span><span class="p">...);</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">make_zip_iterator</span></code> constructs and returns an instance of <code class="code docutils literal notranslate"><span class="pre">zip_iterator</span></code>
using the set of source iterators provided.</p>
</div>
<div class="section" id="parallel-algorithms">
<h2>Parallel Algorithms<a class="headerlink" href="#parallel-algorithms" title="Permalink to this headline">¶</a></h2>
<p>The parallel algorithms are defined in the <code class="code docutils literal notranslate"><span class="pre">&lt;oneapi/dpl/algorithm&gt;</span></code> header,
in <code class="code docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">oneapi::dpl</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Policy</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputKeyIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputValueIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">OutputValueIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">BinaryPred</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputKeyIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">BinaryOp</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="n">OutputValueIt</span>
<span class="n">exclusive_scan_by_segment</span><span class="p">(</span><span class="n">Policy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">InputKeyIt</span> <span class="n">keys_first</span><span class="p">,</span>
    <span class="n">InputKeyIt</span> <span class="n">keys_last</span><span class="p">,</span> <span class="n">InputValueIt</span> <span class="n">values_first</span><span class="p">,</span> <span class="n">OutputValueIt</span> <span class="n">values_result</span><span class="p">,</span>
    <span class="n">T</span> <span class="n">initial_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">BinaryPred</span> <span class="n">binary_pred</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputKeyIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">(),</span>
    <span class="n">BinaryOp</span> <span class="n">binary_op</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::exclusive_scan_by_segment</span></code> performs partial prefix scans by applying the
<code class="code docutils literal notranslate"><span class="pre">binary_op</span></code> operation to a sequence of values. Each partial scan applies to a contiguous
subsequence determined by the keys associated with the values being equal according to the
<code class="code docutils literal notranslate"><span class="pre">binary_pred</span></code> predicate, and the first element of each scan is the initial value provided.
The return value is an iterator targeting the end of the result sequence.</p>
<p>The initial value used if one is not provided is an instance of the <code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the
<code class="code docutils literal notranslate"><span class="pre">InputValueIt</span></code> iterator type initialized to 0. If no binary predicate is provided for the
comparison of keys an instance of <code class="code docutils literal notranslate"><span class="pre">std::equal_to</span></code> with the <code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the
<code class="code docutils literal notranslate"><span class="pre">InputKeyIt</span></code> iterator type is used.  Finally, an instance of <code class="code docutils literal notranslate"><span class="pre">std::plus</span></code> with the
<code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the <code class="code docutils literal notranslate"><span class="pre">InputValueIt</span></code> iterator type is used if no binary operator is
provided to combine the elements of the value subsequences.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Policy</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputKeyIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputValueIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">OutputValueIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">BinaryPredcate</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputKeyIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">BinaryOp</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="n">OutputValueIt</span>
<span class="n">inclusive_scan_by_segment</span><span class="p">(</span><span class="n">Policy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">InputKeyIt</span> <span class="n">keys_first</span><span class="p">,</span>
    <span class="n">InputKeyIt</span> <span class="n">keys_last</span><span class="p">,</span> <span class="n">InputValueIt</span> <span class="n">values_first</span><span class="p">,</span> <span class="n">OutputValueIt</span> <span class="n">values_result</span>
    <span class="n">BinaryPred</span> <span class="n">binary_pred</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputKeyIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">(),</span>
    <span class="n">BinaryOp</span> <span class="n">binary_op</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::inclusive_scan_by_segment</span></code> performs partial prefix scans by applying the
<code class="code docutils literal notranslate"><span class="pre">binary_op</span></code> operation to a sequence of values. Each partial scan applies to a contiguous
subsequence determined by the keys associated with the values being equal according to the
<code class="code docutils literal notranslate"><span class="pre">binary_pred</span></code> predicate. The return value is an iterator targeting the end of the result
sequence.</p>
<p>If no binary predicate is provided for the comparison of keys an instance of <code class="code docutils literal notranslate"><span class="pre">std::equal_to</span></code>
with the <code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the <code class="code docutils literal notranslate"><span class="pre">InputKeyIt</span></code> iterator type is used.  An instance of
<code class="code docutils literal notranslate"><span class="pre">std::plus</span></code> with the <code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the <code class="code docutils literal notranslate"><span class="pre">InputValueIt</span></code> iterator type is used if
no binary operator is provided to combine the elements of the value subsequences.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Policy</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputKeyIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputValueIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">OutputKeyIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutputValueIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">BinaryPredcate</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputKeyIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">BinaryOp</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">OutputKeyIt</span><span class="p">,</span><span class="n">OutputValueIt</span><span class="o">&gt;</span>
<span class="n">reduce_by_segment</span><span class="p">(</span><span class="n">Policy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">InputKeyIt</span> <span class="n">keys_first</span><span class="p">,</span> <span class="n">InputKeyIt</span> <span class="n">keys_last</span><span class="p">,</span>
    <span class="n">InputValueIt</span> <span class="n">values_first</span><span class="p">,</span> <span class="n">OutputKeyIt</span> <span class="n">keys_result</span><span class="p">,</span>
    <span class="n">OutputValueIt</span> <span class="n">values_result</span><span class="p">,</span>
    <span class="n">BinaryPred</span> <span class="n">binary_pred</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputKeyIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">(),</span>
    <span class="n">BinaryOp</span> <span class="n">binary_op</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputValueIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::reduce_by_segment</span></code> performs partial reductions on a sequence of values. Each
reduction is computed with the <code class="code docutils literal notranslate"><span class="pre">binary_op</span></code> operation for a contiguous subsequence of values
determined by the associated keys being equal according to the <code class="code docutils literal notranslate"><span class="pre">binary_pred</span></code> predicate.
For each subsequence the first of the equal keys is stored into <code class="code docutils literal notranslate"><span class="pre">keys_result</span></code> and the computed
reduction is stored into <code class="code docutils literal notranslate"><span class="pre">values_result</span></code>. The return value is a pair of
iterators holding the end of the resulting sequences.</p>
<p>If no binary predicate is provided for the comparison of keys an instance of <code class="code docutils literal notranslate"><span class="pre">std::equal_to</span></code>
with the <code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the <code class="code docutils literal notranslate"><span class="pre">InputKeyIt</span></code> iterator type is used. An instance of
<code class="code docutils literal notranslate"><span class="pre">std::plus</span></code> with the <code class="code docutils literal notranslate"><span class="pre">value_type</span></code> of the <code class="code docutils literal notranslate"><span class="pre">InputValueIt</span></code> iterator type is used to
combine the values in each subsequence identified if a binary operator is not provided.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Policy</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputIt1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputIt2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutputIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">Comparator</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="n">OutputIt</span>
<span class="n">binary_search</span><span class="p">(</span><span class="n">Policy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">InputIt1</span> <span class="n">start</span><span class="p">,</span> <span class="n">InputIt1</span> <span class="n">end</span><span class="p">,</span>
    <span class="n">InputIt2</span> <span class="n">value_first</span><span class="p">,</span> <span class="n">InputIt2</span> <span class="n">value_last</span><span class="p">,</span> <span class="n">OutputIterator</span> <span class="n">result</span><span class="p">,</span>
    <span class="n">Comparator</span> <span class="n">comp</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt1</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::binary_search</span></code> performs a binary search over the data in <code class="code docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">end)</span></code>
for each value in <code class="code docutils literal notranslate"><span class="pre">[value_first,</span> <span class="pre">value_last)</span></code>.  If the value exists in the data searched then
the corresponding element in <code class="code docutils literal notranslate"><span class="pre">[result,</span> <span class="pre">result</span> <span class="pre">+</span> <span class="pre">distance(value_first,</span> <span class="pre">value_last))</span></code> is set to
true, otherwise it is set to false.</p>
<p>If no comparator is provided, <code class="code docutils literal notranslate"><span class="pre">operator&lt;</span></code> is used to determine
when the search value is less than an element in the range being searched.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Policy</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputIt1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputIt2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutputIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">Comparator</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="n">OutputIt</span>
<span class="n">lower_bound</span><span class="p">(</span><span class="n">Policy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">InputIt1</span> <span class="n">start</span><span class="p">,</span> <span class="n">InputIt1</span> <span class="n">end</span><span class="p">,</span>
    <span class="n">InputIt2</span> <span class="n">value_first</span><span class="p">,</span> <span class="n">InputIt2</span> <span class="n">value_last</span><span class="p">,</span> <span class="n">OutputIterator</span> <span class="n">result</span><span class="p">,</span>
    <span class="n">Comparator</span> <span class="n">comp</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt1</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::lower_bound</span></code> performs a binary search over the data in <code class="code docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">end)</span></code> for
each value in <code class="code docutils literal notranslate"><span class="pre">[value_first,</span> <span class="pre">value_last)</span></code> to find the lowest index at which the search value
could be inserted in <code class="code docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">end)</span></code> without violating the ordering defined by the comparator
provided. That lowest index is then assigned to the corresponding element in
<code class="code docutils literal notranslate"><span class="pre">[result,</span> <span class="pre">result</span> <span class="pre">+</span> <span class="pre">distance(value_first,</span> <span class="pre">value_last))</span></code>.</p>
<p>If no comparator is provided, <code class="code docutils literal notranslate"><span class="pre">operator&lt;</span></code> is used to determine
when the search value is less than an element in the range being searched.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Policy</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputIt1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputIt2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutputIt</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">Comparator</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="n">OutputIt</span>
<span class="n">upper_bound</span><span class="p">(</span><span class="n">Policy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">InputIt1</span> <span class="n">start</span><span class="p">,</span> <span class="n">InputIt1</span> <span class="n">end</span><span class="p">,</span>
    <span class="n">InputIt2</span> <span class="n">value_first</span><span class="p">,</span> <span class="n">InputIt2</span> <span class="n">value_last</span><span class="p">,</span> <span class="n">OutputIterator</span> <span class="n">result</span><span class="p">,</span>
    <span class="n">Comparator</span> <span class="n">comp</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIt1</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">oneapi::dpl::upper_bound</span></code> performs a binary search over the data in <code class="code docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">end)</span></code>
for each value in <code class="code docutils literal notranslate"><span class="pre">[value_first,</span> <span class="pre">value_last)</span></code> to find the highest index at which the search
value could be inserted in <code class="code docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">end)</span></code> without violating the ordering defined by the
comparator provided. That highest index is then assigned to the corresponding element in
<code class="code docutils literal notranslate"><span class="pre">[result,</span> <span class="pre">result</span> <span class="pre">+</span> <span class="pre">distance(value_first,</span> <span class="pre">value_last))</span></code>.</p>
<p>If no comparator is provided, <code class="code docutils literal notranslate"><span class="pre">operator&lt;</span></code> is used to determine
when the search value is less than an element in the range being searched.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../oneDNN/source/index.html" class="btn btn-neutral float-right" title="oneDNN" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pstl.html" class="btn btn-neutral float-left" title="Extensions to Parallel STL" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Intel Corporation

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>